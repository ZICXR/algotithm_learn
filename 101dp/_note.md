# ch1 提高-动态规划

dp 思考方式 从集合角度来考虑DP问题
- 动态规划 【详细见摘花生图】
    - 状态表示 f[i, j]  (线性f[i] 网格图f[i][j] 背包f[物品][体积] )
        - 集合
        - 属性  最大值 最小值 数量
    - 状态计算 （集合的划分） 很重要的划分依据：“最后”
        - 根据结果可能的来源进行划分  结果=f(各个子集结果)
        - 划分原则 不重（不一定满足）  不漏（一定要满足）

## 0 数字三角形模型
题谱：
<img src="img/szsjx.png">

### 摘花生
思考方法：
<img src="img/zhs.png">

### 最低通行费
不走回头路 走2n-1步
思考方法：
<img src="img/zdtxf.png">
与摘花生区分；最小值要处理一下特殊情况，因为从边界（0）走过来永远是最小的，所以第一行或者第一列，永远只能从左边(第一行)或上面下来(第一列)
一种思路 边界设为最大值  0* 或 *0 全部设为无穷
另一种思路： i > 1 ； j > 1分别判断处理  先算从上面来的  再算从左边来的，取最小值

### 方格取数
思考方法
<img src="img/fgqs.png">


## 1 最长上升子序列模型 LIS
题谱：
<img src="img/zcsszxl.png">

思考方法：
<img src="img/zcsszxlskff.png">

### 怪盗基德的滑翔翼
双向 LIS
思考方法：
<img src="img/gdjddhxy.png">


### 登山

思考方法：
<img src="img/ds.png">


### 合唱队形

思考方法: 与登山问题一样，就是总数减去序列数


### 友好城市
思考方法：
<img src="img/yhcs.png">

先排序一边的城市，另一边城市找上升子序列

### 最大上升子序列和

思考方法
<img src="img/zdsszxlh.png">


### 拦截导弹
LIS + 贪心
思考方式
<img src="img/ljdd.png">
** 一个序列最少可以被几个非上升子序列覆盖 = 最长上升子序列**


### 导弹防御系统
<span style="color:red">**多刷**</span></br>
LIS + 贪心 + dfs[求最小步数]
思考方式
    每个数都尝试放到递增或递减序列当中

- dfs  求最小步数 
    - 记录全局最小值
    - 迭代加深

- bfs 需要的空间太大 不好剪枝

### 最长上升公共子序列
思考方法
<img src="img/zcssggzxl.png">


## 3 背包问题
题谱：
<img src="img/bbwt.png">

回顾背包模型：
### 01背包 【每种物品只有一个】
<img src="img/01bb.png">

### 完全背包 【每种物品无限个】
<img src="img/wqbb.png">
优化：【求所有前缀的最大值】

```
f[i, j] = max(f[i-1, j], f[i-1, j-v] + w, f[i-1, j-2v] + 2w,...,f[i-1, j-sv] + sw)     注意：s是不变的 = j/v 满足sv <= j 的最大的s 因为可以选无限个  所以理论上可以有无限项
f[i, j-v] = max(f[i-1, j-v], f[i-1, j-2v] + w, f[i-1, j-3v] + 2w,...,f[i-1, j-sv] + (s-1)w)

故：f[i, j] = max(f[i-1, j], f[i, j-v] + w)
```

1. 当空间优化为一维之后，只有完全背包（和多重背包的某种优化方法）的体积是从小到大循环的 【如果空间是两维的话没有限制】
2. 优化完体积之后，所有的背包问题按一下循环顺序
for 物品
    for 体积
        for 决策 (枚举每一个子集)

### 多重背包 【每种物品有限个】
<img src="img/dcbb3.png">
与完全背包类似，只不过物品数枚举到每种物品的上限受限制
优化：【求前面长度为s的滑动窗口的最大值】

```
f[i, j] = max(f[i-1, j], f[i-1, j-v] + w, f[i-1, j-2v] + 2w,...,f[i-1, j-sv] + sw)   注意：s是会变的，因为每个物品可选的个数不定 也就是有限项

f[i, j-v] = max(f[i-1, j-v], f[i-1, j-v-v] + w, f[i-1, j-v-2v] + 2w,...,f[i-1, j-v-sv] + sw)
          = max(f[i-1, j-v], f[i-1, j-2v] + w, f[i-1, j-3v] + 2w,...,f[i-1, j-(s+1)v] + sw)



其实就是计算往前s个窗口的最大值

故：f[i, j] = max(f[i-1, j], f[i, j-v] + w)
```
多重背包问题三： 单调队列 + 背包



